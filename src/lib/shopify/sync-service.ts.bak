import { getDb } from '@/lib/database/connection';
import { 
  tenants,
  dashboardOrders, 
  dashboardCustomers, 
  dashboardProducts,
  webhookLogs 
} from '@/lib/database/schemas/tenants';
import { eq } from 'drizzle-orm';
import { createShopifyClient, ShopifyClient } from './client';
import { ShopifyOrder, ShopifyCustomer, ShopifyProduct } from '@/types/dashboard';
import cron from 'node-cron';

export interface SyncOptions {
  tenantId: number;
  fullSync?: boolean;
  syncOrders?: boolean;
  syncCustomers?: boolean;
  syncProducts?: boolean;
  batchSize?: number;
  maxRetries?: number;
}

export interface SyncResult {
  success: boolean;
  tenantId: number;
  timestamp: Date;
  stats: {
    ordersProcessed: number;
    customersProcessed: number;
    productsProcessed: number;
    errors: number;
  };
  errors?: any[];
  duration: number;
}

export class ShopifyDataSyncService {
  private clients: Map<number, ShopifyClient> = new Map();
  private syncInProgress: Set<number> = new Set();

  constructor() {
    this.initializeClients();
    this.setupCronJobs();
  }

  private async initializeClients() {
    try {
      const db = getDb();
      const activeTenants = await db
        .select()
        .from(tenants)
        .where(eq(tenants.isActive, true));

      for (const tenant of activeTenants) {
        if (tenant.shopifyAccessToken && tenant.shopifyStoreUrl) {
          const client = createShopifyClient({
            storeUrl: tenant.shopifyStoreUrl,
            accessToken: tenant.shopifyAccessToken, // In production, this should be decrypted
          });
          
          this.clients.set(tenant.id, client);
        }
      }

      console.log(`Initialized ${this.clients.size} Shopify clients`);\n    } catch (error) {\n      console.error('Failed to initialize Shopify clients:', error);\n    }\n  }\n\n  private setupCronJobs() {\n    // Run sync every hour for all active tenants\n    cron.schedule('0 * * * *', async () => {\n      console.log('Starting scheduled sync for all tenants');\n      await this.syncAllTenants();\n    });\n\n    // Run full sync daily at 2 AM\n    cron.schedule('0 2 * * *', async () => {\n      console.log('Starting daily full sync for all tenants');\n      await this.syncAllTenants({ fullSync: true });\n    });\n  }\n\n  async syncAllTenants(options: Omit<SyncOptions, 'tenantId'> = {}): Promise<SyncResult[]> {\n    const results: SyncResult[] = [];\n    \n    for (const [tenantId] of this.clients) {\n      try {\n        const result = await this.syncTenant({ ...options, tenantId });\n        results.push(result);\n      } catch (error) {\n        console.error(`Failed to sync tenant ${tenantId}:`, error);\n        results.push({\n          success: false,\n          tenantId,\n          timestamp: new Date(),\n          stats: { ordersProcessed: 0, customersProcessed: 0, productsProcessed: 0, errors: 1 },\n          errors: [error],\n          duration: 0,\n        });\n      }\n    }\n\n    return results;\n  }\n\n  async syncTenant(options: SyncOptions): Promise<SyncResult> {\n    const startTime = Date.now();\n    const { tenantId } = options;\n    \n    // Prevent concurrent syncs for the same tenant\n    if (this.syncInProgress.has(tenantId)) {\n      throw new Error(`Sync already in progress for tenant ${tenantId}`);\n    }\n\n    this.syncInProgress.add(tenantId);\n    \n    const result: SyncResult = {\n      success: false,\n      tenantId,\n      timestamp: new Date(),\n      stats: {\n        ordersProcessed: 0,\n        customersProcessed: 0,\n        productsProcessed: 0,\n        errors: 0,\n      },\n      errors: [],\n      duration: 0,\n    };\n\n    try {\n      const client = this.clients.get(tenantId);\n      if (!client) {\n        throw new Error(`No Shopify client found for tenant ${tenantId}`);\n      }\n\n      // Health check\n      const isHealthy = await client.healthCheck();\n      if (!isHealthy) {\n        throw new Error('Shopify API health check failed');\n      }\n\n      // Sync orders\n      if (options.syncOrders !== false) {\n        try {\n          const ordersResult = await this.syncOrders(client, tenantId, options);\n          result.stats.ordersProcessed = ordersResult.processed;\n        } catch (error) {\n          result.stats.errors++;\n          result.errors?.push({ type: 'orders', error });\n        }\n      }\n\n      // Sync customers\n      if (options.syncCustomers !== false) {\n        try {\n          const customersResult = await this.syncCustomers(client, tenantId, options);\n          result.stats.customersProcessed = customersResult.processed;\n        } catch (error) {\n          result.stats.errors++;\n          result.errors?.push({ type: 'customers', error });\n        }\n      }\n\n      // Sync products\n      if (options.syncProducts !== false) {\n        try {\n          const productsResult = await this.syncProducts(client, tenantId, options);\n          result.stats.productsProcessed = productsResult.processed;\n        } catch (error) {\n          result.stats.errors++;\n          result.errors?.push({ type: 'products', error });\n        }\n      }\n\n      result.success = result.stats.errors === 0;\n    } catch (error) {\n      result.stats.errors++;\n      result.errors?.push({ type: 'general', error });\n    } finally {\n      this.syncInProgress.delete(tenantId);\n      result.duration = Date.now() - startTime;\n    }\n\n    return result;\n  }\n\n  private async syncOrders(\n    client: ShopifyClient, \n    tenantId: number, \n    options: SyncOptions\n  ): Promise<{ processed: number }> {\n    let processed = 0;\n    const batchSize = options.batchSize || 250;\n    \n    // Determine the date range for incremental sync\n    let updatedAtMin: string | undefined;\n    \n    if (!options.fullSync) {\n      // Get the most recent order update timestamp\n      const lastOrder = await db\n        .select({ shopifyUpdatedAt: dashboardOrders.shopifyUpdatedAt })\n        .from(dashboardOrders)\n        .where(eq(dashboardOrders.tenantId, tenantId))\n        .orderBy(dashboardOrders.shopifyUpdatedAt)\n        .limit(1);\n      \n      if (lastOrder.length > 0 && lastOrder[0].shopifyUpdatedAt) {\n        updatedAtMin = lastOrder[0].shopifyUpdatedAt.toISOString();\n      }\n    }\n\n    const { items: orders } = await client.batchImport<ShopifyOrder>(\n      async (cursor) => {\n        const response = await client.getOrders({\n          limit: batchSize,\n          sinceId: cursor,\n          updatedAtMin,\n          status: 'any',\n        });\n        \n        return {\n          ...response,\n          data: response.data?.orders || [],\n        };\n      },\n      async (ordersBatch) => {\n        await this.processOrdersBatch(ordersBatch, tenantId);\n        processed += ordersBatch.length;\n      }\n    );\n\n    return { processed };\n  }\n\n  private async processOrdersBatch(orders: ShopifyOrder[], tenantId: number) {\n    for (const order of orders) {\n      try {\n        await this.upsertOrder(order, tenantId);\n      } catch (error) {\n        console.error(`Failed to process order ${order.id}:`, error);\n      }\n    }\n  }\n\n  private async upsertOrder(order: ShopifyOrder, tenantId: number) {\n    // First, handle the customer if present\n    let customerId: number | null = null;\n    \n    if (order.customer) {\n      customerId = await this.upsertCustomer(order.customer, tenantId);\n    }\n\n    // Check if order exists\n    const existingOrder = await db\n      .select()\n      .from(dashboardOrders)\n      .where(eq(dashboardOrders.shopifyOrderId, order.id.toString()))\n      .limit(1);\n\n    const orderData = {\n      tenantId,\n      shopifyOrderId: order.id.toString(),\n      customerId,\n      orderNumber: order.order_number,\n      email: order.email,\n      totalPrice: order.total_price,\n      subtotalPrice: order.subtotal_price,\n      totalTax: order.total_tax,\n      totalDiscounts: order.total_discounts,\n      currency: order.currency,\n      financialStatus: order.financial_status,\n      fulfillmentStatus: order.fulfillment_status,\n      orderDate: new Date(order.created_at),\n      processedAt: order.processed_at ? new Date(order.processed_at) : null,\n      lineItems: order.line_items,\n      billingAddress: order.billing_address,\n      shippingAddress: order.shipping_address,\n      discountCodes: order.discount_codes,\n      shopifyCreatedAt: new Date(order.created_at),\n      shopifyUpdatedAt: new Date(order.updated_at),\n      updatedAt: new Date(),\n    };\n\n    if (existingOrder.length > 0) {\n      await db\n        .update(dashboardOrders)\n        .set(orderData)\n        .where(eq(dashboardOrders.id, existingOrder[0].id));\n    } else {\n      await db.insert(dashboardOrders).values(orderData);\n    }\n  }\n\n  private async syncCustomers(\n    client: ShopifyClient, \n    tenantId: number, \n    options: SyncOptions\n  ): Promise<{ processed: number }> {\n    let processed = 0;\n    const batchSize = options.batchSize || 250;\n    \n    let updatedAtMin: string | undefined;\n    \n    if (!options.fullSync) {\n      const lastCustomer = await db\n        .select({ shopifyUpdatedAt: dashboardCustomers.shopifyUpdatedAt })\n        .from(dashboardCustomers)\n        .where(eq(dashboardCustomers.tenantId, tenantId))\n        .orderBy(dashboardCustomers.shopifyUpdatedAt)\n        .limit(1);\n      \n      if (lastCustomer.length > 0 && lastCustomer[0].shopifyUpdatedAt) {\n        updatedAtMin = lastCustomer[0].shopifyUpdatedAt.toISOString();\n      }\n    }\n\n    await client.batchImport<ShopifyCustomer>(\n      async (cursor) => {\n        const response = await client.getCustomers({\n          limit: batchSize,\n          sinceId: cursor,\n          updatedAtMin,\n        });\n        \n        return {\n          ...response,\n          data: response.data?.customers || [],\n        };\n      },\n      async (customersBatch) => {\n        for (const customer of customersBatch) {\n          try {\n            await this.upsertCustomer(customer, tenantId);\n            processed++;\n          } catch (error) {\n            console.error(`Failed to process customer ${customer.id}:`, error);\n          }\n        }\n      }\n    );\n\n    return { processed };\n  }\n\n  private async upsertCustomer(customer: ShopifyCustomer, tenantId: number): Promise<number> {\n    const existingCustomer = await db\n      .select()\n      .from(dashboardCustomers)\n      .where(eq(dashboardCustomers.shopifyCustomerId, customer.id.toString()))\n      .limit(1);\n\n    const customerData = {\n      tenantId,\n      shopifyCustomerId: customer.id.toString(),\n      email: customer.email,\n      firstName: customer.first_name,\n      lastName: customer.last_name,\n      phone: customer.phone,\n      totalSpent: customer.total_spent,\n      ordersCount: customer.orders_count,\n      state: customer.state,\n      acceptsMarketing: customer.accepts_marketing,\n      tags: customer.tags,\n      shopifyCreatedAt: new Date(customer.created_at),\n      shopifyUpdatedAt: new Date(customer.updated_at),\n      updatedAt: new Date(),\n    };\n\n    if (existingCustomer.length > 0) {\n      await db\n        .update(dashboardCustomers)\n        .set(customerData)\n        .where(eq(dashboardCustomers.id, existingCustomer[0].id));\n      return existingCustomer[0].id;\n    } else {\n      const [newCustomer] = await db\n        .insert(dashboardCustomers)\n        .values(customerData)\n        .returning();\n      return newCustomer.id;\n    }\n  }\n\n  private async syncProducts(\n    client: ShopifyClient, \n    tenantId: number, \n    options: SyncOptions\n  ): Promise<{ processed: number }> {\n    let processed = 0;\n    const batchSize = options.batchSize || 250;\n    \n    let updatedAtMin: string | undefined;\n    \n    if (!options.fullSync) {\n      const lastProduct = await db\n        .select({ shopifyUpdatedAt: dashboardProducts.shopifyUpdatedAt })\n        .from(dashboardProducts)\n        .where(eq(dashboardProducts.tenantId, tenantId))\n        .orderBy(dashboardProducts.shopifyUpdatedAt)\n        .limit(1);\n      \n      if (lastProduct.length > 0 && lastProduct[0].shopifyUpdatedAt) {\n        updatedAtMin = lastProduct[0].shopifyUpdatedAt.toISOString();\n      }\n    }\n\n    await client.batchImport<ShopifyProduct>(\n      async (cursor) => {\n        const response = await client.getProducts({\n          limit: batchSize,\n          sinceId: cursor,\n          updatedAtMin,\n          status: 'active',\n        });\n        \n        return {\n          ...response,\n          data: response.data?.products || [],\n        };\n      },\n      async (productsBatch) => {\n        for (const product of productsBatch) {\n          try {\n            await this.upsertProduct(product, tenantId);\n            processed++;\n          } catch (error) {\n            console.error(`Failed to process product ${product.id}:`, error);\n          }\n        }\n      }\n    );\n\n    return { processed };\n  }\n\n  private async upsertProduct(product: ShopifyProduct, tenantId: number) {\n    const existingProduct = await db\n      .select()\n      .from(dashboardProducts)\n      .where(eq(dashboardProducts.shopifyProductId, product.id.toString()))\n      .limit(1);\n\n    const productData = {\n      tenantId,\n      shopifyProductId: product.id.toString(),\n      title: product.title,\n      handle: product.handle,\n      vendor: product.vendor,\n      productType: product.product_type,\n      status: product.status,\n      tags: product.tags,\n      variants: product.variants,\n      images: product.images,\n      shopifyCreatedAt: new Date(product.created_at),\n      shopifyUpdatedAt: new Date(product.updated_at),\n      updatedAt: new Date(),\n    };\n\n    if (existingProduct.length > 0) {\n      await db\n        .update(dashboardProducts)\n        .set(productData)\n        .where(eq(dashboardProducts.id, existingProduct[0].id));\n    } else {\n      await db.insert(dashboardProducts).values(productData);\n    }\n  }\n\n  // Manual sync trigger\n  async triggerSync(tenantId: number, options: Omit<SyncOptions, 'tenantId'> = {}): Promise<SyncResult> {\n    return this.syncTenant({ ...options, tenantId });\n  }\n\n  // Get sync status\n  isSyncInProgress(tenantId: number): boolean {\n    return this.syncInProgress.has(tenantId);\n  }\n\n  // Add new tenant client\n  async addTenantClient(tenantId: number) {\n    try {\n      const tenant = await db\n        .select()\n        .from(tenants)\n        .where(eq(tenants.id, tenantId))\n        .limit(1);\n\n      if (tenant.length > 0 && tenant[0].shopifyAccessToken && tenant[0].shopifyStoreUrl) {\n        const client = createShopifyClient({\n          storeUrl: tenant[0].shopifyStoreUrl,\n          accessToken: tenant[0].shopifyAccessToken,\n        });\n        \n        this.clients.set(tenantId, client);\n        console.log(`Added Shopify client for tenant ${tenantId}`);\n      }\n    } catch (error) {\n      console.error(`Failed to add client for tenant ${tenantId}:`, error);\n    }\n  }\n\n  // Remove tenant client\n  removeTenantClient(tenantId: number) {\n    this.clients.delete(tenantId);\n    console.log(`Removed Shopify client for tenant ${tenantId}`);\n  }\n}\n\n// Singleton instance\nlet syncServiceInstance: ShopifyDataSyncService | null = null;\n\nexport function getShopifyDataSyncService(): ShopifyDataSyncService {\n  if (!syncServiceInstance) {\n    syncServiceInstance = new ShopifyDataSyncService();\n  }\n  return syncServiceInstance;\n}\n\nexport { ShopifyDataSyncService };
